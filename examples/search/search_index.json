{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the TTK Examples! \u00b6 This website hosts a list of data analysis pipelines exemplifying the usage of TTK with ParaView and its Python API pvpython . This website is targeting novice users who are not power users of ParaView but who would like to get started with topological data analysis with TTK in Python. Each example includes: a screenshot (or a tutorial video) a short description the command line to reproduce the example with ParaView the corresponding Python code, to: load the input data execute the analysis pipeline store the output to disk (for later analysis or visualization, e.g. with ParaView ) a description of the inputs and outputs pointers to the corresponding C++/Python documentation This documentation assumes a default TTK installation (with the pvpython API support enabled) and that the repository ttk-data has been downloaded locally. List of available examples \u00b6 Scalar data \u00b6 Dragon example Morse persistence example Built-in example 1 Interaction site example Viscous fingering example Morse molecule example Tectonic puzzle example Ocean vortices example Contour around point example CT bones example Tribute example Image processing example Persistence driven compression example Morse-Smale quadrangulation example Bivariate scalar data \u00b6 Built-in example 2 Bivariate toy example Bivariate toy CSP peeling example Mechanical example Uncertain scalar data \u00b6 Built-in example 3 Uncertain starting vortex example Time-varying scalar data \u00b6 Time tracking example Merge tree feature tracking example Merge tree temporal reduction example Nested tracking graph example Ensemble scalar data \u00b6 Persistence diagram distance example Persistence diagram clustering example Merge tree clustering example Contour tree alignment example High-dimensional / point cloud data \u00b6 Persistence clustering gallery example Persistence clustering0 example Persistence clustering1 example Persistence clustering2 example Persistence clustering3 example Persistence clustering4 example Karhunen-Love Digits 64-Dimensions example 1-manifold learning example 1-manifold learning circles example 2-manifold learning example In-situ features \u00b6 Geometry approximation example Cinema darkroom example Misc features \u00b6 Manifold checks example","title":"Welcome to the TTK Examples!"},{"location":"#welcome-to-the-ttk-examples","text":"This website hosts a list of data analysis pipelines exemplifying the usage of TTK with ParaView and its Python API pvpython . This website is targeting novice users who are not power users of ParaView but who would like to get started with topological data analysis with TTK in Python. Each example includes: a screenshot (or a tutorial video) a short description the command line to reproduce the example with ParaView the corresponding Python code, to: load the input data execute the analysis pipeline store the output to disk (for later analysis or visualization, e.g. with ParaView ) a description of the inputs and outputs pointers to the corresponding C++/Python documentation This documentation assumes a default TTK installation (with the pvpython API support enabled) and that the repository ttk-data has been downloaded locally.","title":"Welcome to the TTK Examples!"},{"location":"#list-of-available-examples","text":"","title":"List of available examples"},{"location":"#scalar-data","text":"Dragon example Morse persistence example Built-in example 1 Interaction site example Viscous fingering example Morse molecule example Tectonic puzzle example Ocean vortices example Contour around point example CT bones example Tribute example Image processing example Persistence driven compression example Morse-Smale quadrangulation example","title":"Scalar data"},{"location":"#bivariate-scalar-data","text":"Built-in example 2 Bivariate toy example Bivariate toy CSP peeling example Mechanical example","title":"Bivariate scalar data"},{"location":"#uncertain-scalar-data","text":"Built-in example 3 Uncertain starting vortex example","title":"Uncertain scalar data"},{"location":"#time-varying-scalar-data","text":"Time tracking example Merge tree feature tracking example Merge tree temporal reduction example Nested tracking graph example","title":"Time-varying scalar data"},{"location":"#ensemble-scalar-data","text":"Persistence diagram distance example Persistence diagram clustering example Merge tree clustering example Contour tree alignment example","title":"Ensemble scalar data"},{"location":"#high-dimensional-point-cloud-data","text":"Persistence clustering gallery example Persistence clustering0 example Persistence clustering1 example Persistence clustering2 example Persistence clustering3 example Persistence clustering4 example Karhunen-Love Digits 64-Dimensions example 1-manifold learning example 1-manifold learning circles example 2-manifold learning example","title":"High-dimensional / point cloud data"},{"location":"#in-situ-features","text":"Geometry approximation example Cinema darkroom example","title":"In-situ features"},{"location":"#misc-features","text":"Manifold checks example","title":"Misc features"},{"location":"ctBones/","text":"CT bones example \u00b6 Pipeline description \u00b6 This example segments medical image data based on topological persistence. First, the PersistenceDiagram of the data is computed (top right view, above screenshot). Then, only the 5 most persistent maxima are selected, corresponding to the toes of the foot. Next, the input data is simplified based on the selected persistent features, via TopologicalSimplification . Next, the Split tree of the simplified data is computed. Finally, the geometry of the bones of the toes is extracted by selecting the regions (in the 3D data) attached to the leaves ( RegionType equals 1) of the Split tree (center view, above screenshot). To get a refined segmentation, change the persistence threshold from 180 down to 150 . Each toe will be subdivided into two segments, precisely along the joints. ParaView \u00b6 To reproduce the above screenshot, go to your ttk-data directory and enter the following command: $ paraview states/ctBones.pvsm Python code \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #!/usr/bin/env python from paraview.simple import * # create a new 'XML Image Data Reader' ctBonesvti = XMLImageDataReader ( FileName = [ 'ctBones.vti' ]) # create a new 'TTK PersistenceDiagram' tTKPersistenceDiagram1 = TTKPersistenceDiagram ( Input = ctBonesvti ) tTKPersistenceDiagram1 . ScalarField = [ 'POINTS' , 'Scalars_' ] # create a new 'Threshold' threshold1 = Threshold ( Input = tTKPersistenceDiagram1 ) threshold1 . Scalars = [ 'CELLS' , 'PairIdentifier' ] threshold1 . ThresholdRange = [ 0 , 9999999.0 ] # create a new 'Threshold' persistenceThreshold = Threshold ( Input = threshold1 ) persistenceThreshold . Scalars = [ 'CELLS' , 'Persistence' ] persistenceThreshold . ThresholdRange = [ 180.0 , 255.0 ] # create a new 'TTK TopologicalSimplification' tTKTopologicalSimplification1 = TTKTopologicalSimplification ( Domain = ctBonesvti , Constraints = persistenceThreshold ) tTKTopologicalSimplification1 . ScalarField = [ 'POINTS' , 'Scalars_' ] # create a new 'TTK Merge and Contour Tree (FTM)' tTKMergeandContourTreeFTM1 = TTKMergeandContourTreeFTM ( Input = tTKTopologicalSimplification1 ) tTKMergeandContourTreeFTM1 . ScalarField = [ 'POINTS' , 'Scalars_' ] tTKMergeandContourTreeFTM1 . TreeType = 'Split Tree' # create a new 'Threshold' threshold3 = Threshold ( Input = OutputPort ( tTKMergeandContourTreeFTM1 , 2 )) threshold3 . Scalars = [ 'POINTS' , 'RegionType' ] threshold3 . ThresholdRange = [ 1.0 , 1.0 ] SaveData ( \"CTBonesOutputSegmentation.vtu\" , threshold3 ) Inputs \u00b6 ctBones.vti : a three-dimensional regular grid encoding material density in a medical image (CT scan). Outputs \u00b6 CTBonesOutputSegmentation.vtu : the geometry of the volume of the bones of the toes, as extracted by the analysis pipeline (most persistent super-level set connected components). C++/Python API \u00b6 ContourTree (FTM) PersistenceDiagram TopologicalSimplification","title":"CT bones example"},{"location":"ctBones/#ct-bones-example","text":"","title":"CT bones example"},{"location":"ctBones/#pipeline-description","text":"This example segments medical image data based on topological persistence. First, the PersistenceDiagram of the data is computed (top right view, above screenshot). Then, only the 5 most persistent maxima are selected, corresponding to the toes of the foot. Next, the input data is simplified based on the selected persistent features, via TopologicalSimplification . Next, the Split tree of the simplified data is computed. Finally, the geometry of the bones of the toes is extracted by selecting the regions (in the 3D data) attached to the leaves ( RegionType equals 1) of the Split tree (center view, above screenshot). To get a refined segmentation, change the persistence threshold from 180 down to 150 . Each toe will be subdivided into two segments, precisely along the joints.","title":"Pipeline description"},{"location":"ctBones/#paraview","text":"To reproduce the above screenshot, go to your ttk-data directory and enter the following command: $ paraview states/ctBones.pvsm","title":"ParaView"},{"location":"ctBones/#python-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #!/usr/bin/env python from paraview.simple import * # create a new 'XML Image Data Reader' ctBonesvti = XMLImageDataReader ( FileName = [ 'ctBones.vti' ]) # create a new 'TTK PersistenceDiagram' tTKPersistenceDiagram1 = TTKPersistenceDiagram ( Input = ctBonesvti ) tTKPersistenceDiagram1 . ScalarField = [ 'POINTS' , 'Scalars_' ] # create a new 'Threshold' threshold1 = Threshold ( Input = tTKPersistenceDiagram1 ) threshold1 . Scalars = [ 'CELLS' , 'PairIdentifier' ] threshold1 . ThresholdRange = [ 0 , 9999999.0 ] # create a new 'Threshold' persistenceThreshold = Threshold ( Input = threshold1 ) persistenceThreshold . Scalars = [ 'CELLS' , 'Persistence' ] persistenceThreshold . ThresholdRange = [ 180.0 , 255.0 ] # create a new 'TTK TopologicalSimplification' tTKTopologicalSimplification1 = TTKTopologicalSimplification ( Domain = ctBonesvti , Constraints = persistenceThreshold ) tTKTopologicalSimplification1 . ScalarField = [ 'POINTS' , 'Scalars_' ] # create a new 'TTK Merge and Contour Tree (FTM)' tTKMergeandContourTreeFTM1 = TTKMergeandContourTreeFTM ( Input = tTKTopologicalSimplification1 ) tTKMergeandContourTreeFTM1 . ScalarField = [ 'POINTS' , 'Scalars_' ] tTKMergeandContourTreeFTM1 . TreeType = 'Split Tree' # create a new 'Threshold' threshold3 = Threshold ( Input = OutputPort ( tTKMergeandContourTreeFTM1 , 2 )) threshold3 . Scalars = [ 'POINTS' , 'RegionType' ] threshold3 . ThresholdRange = [ 1.0 , 1.0 ] SaveData ( \"CTBonesOutputSegmentation.vtu\" , threshold3 )","title":"Python code"},{"location":"ctBones/#inputs","text":"ctBones.vti : a three-dimensional regular grid encoding material density in a medical image (CT scan).","title":"Inputs"},{"location":"ctBones/#outputs","text":"CTBonesOutputSegmentation.vtu : the geometry of the volume of the bones of the toes, as extracted by the analysis pipeline (most persistent super-level set connected components).","title":"Outputs"},{"location":"ctBones/#cpython-api","text":"ContourTree (FTM) PersistenceDiagram TopologicalSimplification","title":"C++/Python API"},{"location":"dragon/","text":"Dragon example \u00b6 Pipeline description \u00b6 This example first loads a triangle mesh from disk. In a pre-processing, the mesh is smoothed and an elevation function is computed on top of it. The elevation function will be considered as the input scalar data in the remainder. Then, the PersistenceDiagram is computed and thresholds are applied base on persistence to maintain only the most persistent features. This results in a simplified persistence diagram (bottom right view in the above screenshot). The PersistenceCurve is also computed (top right view in the above screenshot). The simplified persistence diagram is then used as a constraint for the TopologicalSimplification of the input scalar data. This simplified data is then used as the input of the computation of ScalarFieldCriticalPoints (top left view, above screenshot) and the ContourTree (FTM) (bottom left view, above screenshot). ParaView \u00b6 To reproduce the above screenshot, go to your ttk-data directory and enter the following command: $ paraview states/dragon.pvsm Python code \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #!/usr/bin/env python from paraview.simple import * # create a new 'XML Unstructured Grid Reader' dragonvtu = XMLUnstructuredGridReader ( FileName = [ 'dragon.vtu' ]) # create a new 'TTK GeometrySmoother' tTKGeometrySmoother1 = TTKGeometrySmoother ( Input = dragonvtu ) # create a new 'Calculator' elevation = Calculator ( Input = tTKGeometrySmoother1 ) elevation . ResultArrayName = 'Elevation' elevation . Function = 'coordsY' # create a new 'TTK PersistenceCurve' tTKPersistenceCurve1 = TTKPersistenceCurve ( Input = elevation ) tTKPersistenceCurve1 . ScalarField = [ 'POINTS' , 'Elevation' ] # create a new 'TTK PersistenceDiagram' tTKPersistenceDiagram1 = TTKPersistenceDiagram ( Input = elevation ) tTKPersistenceDiagram1 . ScalarField = [ 'POINTS' , 'Elevation' ] # create a new 'Threshold' pairs = Threshold ( Input = tTKPersistenceDiagram1 ) pairs . Scalars = [ 'CELLS' , 'PairIdentifier' ] pairs . ThresholdRange = [ 0.0 , 1000.0 ] # create a new 'Threshold' persistenceThreshold = Threshold ( Input = pairs ) persistenceThreshold . Scalars = [ 'CELLS' , 'Persistence' ] persistenceThreshold . ThresholdRange = [ 5.0 , 1000.0 ] # create a new 'TTK TopologicalSimplification' tTKTopologicalSimplification1 = TTKTopologicalSimplification ( Domain = elevation , Constraints = persistenceThreshold ) tTKTopologicalSimplification1 . ScalarField = [ 'POINTS' , 'Elevation' ] # create a new 'TTK ScalarFieldCriticalPoints' tTKScalarFieldCriticalPoints1 = TTKScalarFieldCriticalPoints ( Input = tTKTopologicalSimplification1 ) tTKScalarFieldCriticalPoints1 . ScalarField = [ 'POINTS' , 'Elevation' ] # create a new 'TTK Merge and Contour Tree (FTM)' tTKContourTree1 = TTKMergeandContourTreeFTM ( Input = tTKTopologicalSimplification1 ) tTKContourTree1 . ScalarField = [ 'POINTS' , 'Elevation' ] tTKContourTree1 . ArcSampling = 30 # create a new 'TTK GeometrySmoother' tTKGeometrySmoother2 = TTKGeometrySmoother ( Input = OutputPort ( tTKContourTree1 , 1 )) tTKGeometrySmoother2 . IterationNumber = 40 # create a new 'Extract Surface' extractSurface4 = ExtractSurface ( Input = tTKGeometrySmoother2 ) # create a new 'Tube' tube4 = Tube ( Input = extractSurface4 ) tube4 . NumberofSides = 12 tube4 . Radius = 0.75 # create a new 'TTK IcospheresFromPoints' tTKIcospheresFromPoints4 = TTKIcospheresFromPoints ( Input = tTKContourTree1 ) tTKIcospheresFromPoints4 . Radius = 2.0 # save the output SaveData ( 'PersistenceDiagram.vtu' , tTKPersistenceDiagram1 ) SaveData ( 'PersistenceCurve.csv' , OutputPort ( tTKPersistenceCurve1 , 3 )) SaveData ( 'CriticalPoints.vtp' , tTKScalarFieldCriticalPoints1 ) SaveData ( 'ContourTreeNodes.vtp' , tTKIcospheresFromPoints4 ) SaveData ( 'ContourTreeArcs.vtp' , tube4 ) Inputs \u00b6 dragon.vtu : a two-dimensional triangulation. Outputs \u00b6 PersistenceDiagram.vtu : the output persistence diagram in VTK file format (bottom right view, above screenshot). You are free to change the vtu file extension to that of any other supported file format (e.g. csv ) in the above python script. PersistenceCurve.csv : the output persistence curve. CriticalPoints.vtp : the output critical points in VTK file format (bottom right view, above screenshot). You are free to change the vtp file extension to that of any other supported file format (e.g. csv ) in the above python script. ContourTreeNode.vtp : spheres, representing the nodes of the output contour tree in VTK file format (bottom right view, above screenshot). You are free to change the vtp file extension to that of any other supported file format (e.g. csv ) in the above python script. ContourTreeArcs.vtp : cylinders, representing the arcs of the output contour tree in VTK file format (bottom right view, above screenshot). You are free to change the vtp file extension to that of any other supported file format (e.g. csv ) in the above python script. C++/Python API \u00b6 ContourTree (FTM) GeometrySmoother IcospheresFromPoints PersistenceCurve PersistenceDiagram ScalarFieldCriticalPoints TopologicalSimplification","title":"Dragon example"},{"location":"dragon/#dragon-example","text":"","title":"Dragon example"},{"location":"dragon/#pipeline-description","text":"This example first loads a triangle mesh from disk. In a pre-processing, the mesh is smoothed and an elevation function is computed on top of it. The elevation function will be considered as the input scalar data in the remainder. Then, the PersistenceDiagram is computed and thresholds are applied base on persistence to maintain only the most persistent features. This results in a simplified persistence diagram (bottom right view in the above screenshot). The PersistenceCurve is also computed (top right view in the above screenshot). The simplified persistence diagram is then used as a constraint for the TopologicalSimplification of the input scalar data. This simplified data is then used as the input of the computation of ScalarFieldCriticalPoints (top left view, above screenshot) and the ContourTree (FTM) (bottom left view, above screenshot).","title":"Pipeline description"},{"location":"dragon/#paraview","text":"To reproduce the above screenshot, go to your ttk-data directory and enter the following command: $ paraview states/dragon.pvsm","title":"ParaView"},{"location":"dragon/#python-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #!/usr/bin/env python from paraview.simple import * # create a new 'XML Unstructured Grid Reader' dragonvtu = XMLUnstructuredGridReader ( FileName = [ 'dragon.vtu' ]) # create a new 'TTK GeometrySmoother' tTKGeometrySmoother1 = TTKGeometrySmoother ( Input = dragonvtu ) # create a new 'Calculator' elevation = Calculator ( Input = tTKGeometrySmoother1 ) elevation . ResultArrayName = 'Elevation' elevation . Function = 'coordsY' # create a new 'TTK PersistenceCurve' tTKPersistenceCurve1 = TTKPersistenceCurve ( Input = elevation ) tTKPersistenceCurve1 . ScalarField = [ 'POINTS' , 'Elevation' ] # create a new 'TTK PersistenceDiagram' tTKPersistenceDiagram1 = TTKPersistenceDiagram ( Input = elevation ) tTKPersistenceDiagram1 . ScalarField = [ 'POINTS' , 'Elevation' ] # create a new 'Threshold' pairs = Threshold ( Input = tTKPersistenceDiagram1 ) pairs . Scalars = [ 'CELLS' , 'PairIdentifier' ] pairs . ThresholdRange = [ 0.0 , 1000.0 ] # create a new 'Threshold' persistenceThreshold = Threshold ( Input = pairs ) persistenceThreshold . Scalars = [ 'CELLS' , 'Persistence' ] persistenceThreshold . ThresholdRange = [ 5.0 , 1000.0 ] # create a new 'TTK TopologicalSimplification' tTKTopologicalSimplification1 = TTKTopologicalSimplification ( Domain = elevation , Constraints = persistenceThreshold ) tTKTopologicalSimplification1 . ScalarField = [ 'POINTS' , 'Elevation' ] # create a new 'TTK ScalarFieldCriticalPoints' tTKScalarFieldCriticalPoints1 = TTKScalarFieldCriticalPoints ( Input = tTKTopologicalSimplification1 ) tTKScalarFieldCriticalPoints1 . ScalarField = [ 'POINTS' , 'Elevation' ] # create a new 'TTK Merge and Contour Tree (FTM)' tTKContourTree1 = TTKMergeandContourTreeFTM ( Input = tTKTopologicalSimplification1 ) tTKContourTree1 . ScalarField = [ 'POINTS' , 'Elevation' ] tTKContourTree1 . ArcSampling = 30 # create a new 'TTK GeometrySmoother' tTKGeometrySmoother2 = TTKGeometrySmoother ( Input = OutputPort ( tTKContourTree1 , 1 )) tTKGeometrySmoother2 . IterationNumber = 40 # create a new 'Extract Surface' extractSurface4 = ExtractSurface ( Input = tTKGeometrySmoother2 ) # create a new 'Tube' tube4 = Tube ( Input = extractSurface4 ) tube4 . NumberofSides = 12 tube4 . Radius = 0.75 # create a new 'TTK IcospheresFromPoints' tTKIcospheresFromPoints4 = TTKIcospheresFromPoints ( Input = tTKContourTree1 ) tTKIcospheresFromPoints4 . Radius = 2.0 # save the output SaveData ( 'PersistenceDiagram.vtu' , tTKPersistenceDiagram1 ) SaveData ( 'PersistenceCurve.csv' , OutputPort ( tTKPersistenceCurve1 , 3 )) SaveData ( 'CriticalPoints.vtp' , tTKScalarFieldCriticalPoints1 ) SaveData ( 'ContourTreeNodes.vtp' , tTKIcospheresFromPoints4 ) SaveData ( 'ContourTreeArcs.vtp' , tube4 )","title":"Python code"},{"location":"dragon/#inputs","text":"dragon.vtu : a two-dimensional triangulation.","title":"Inputs"},{"location":"dragon/#outputs","text":"PersistenceDiagram.vtu : the output persistence diagram in VTK file format (bottom right view, above screenshot). You are free to change the vtu file extension to that of any other supported file format (e.g. csv ) in the above python script. PersistenceCurve.csv : the output persistence curve. CriticalPoints.vtp : the output critical points in VTK file format (bottom right view, above screenshot). You are free to change the vtp file extension to that of any other supported file format (e.g. csv ) in the above python script. ContourTreeNode.vtp : spheres, representing the nodes of the output contour tree in VTK file format (bottom right view, above screenshot). You are free to change the vtp file extension to that of any other supported file format (e.g. csv ) in the above python script. ContourTreeArcs.vtp : cylinders, representing the arcs of the output contour tree in VTK file format (bottom right view, above screenshot). You are free to change the vtp file extension to that of any other supported file format (e.g. csv ) in the above python script.","title":"Outputs"},{"location":"dragon/#cpython-api","text":"ContourTree (FTM) GeometrySmoother IcospheresFromPoints PersistenceCurve PersistenceDiagram ScalarFieldCriticalPoints TopologicalSimplification","title":"C++/Python API"},{"location":"manifoldCheck/","text":"Manifold Check \u00b6 Pipeline description \u00b6 This example loads three different hexahedral geometry files from disk. In a pre-processing, each geometry is tetrahedralized, which is used as input data. On each of the three geometries, ManifoldCheck is executed. This filters adds link numbers to vertices and cells, which can be used to detect and extract non-manifold vertices (left), edges (middle), and faces (right). ParaView \u00b6 To reproduce the above screenshot, go to your ttk-data directory and enter the following command: $ paraview states/manifoldChecks.pvsm Python code \u00b6 Non-manifold Vertices \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/usr/bin/env python from paraview.simple import * # create a new 'XML Unstructured Grid Reader' manifoldCheck0vtu = XMLUnstructuredGridReader ( FileName = [ 'manifoldCheck0.vtu' ]) # create a new 'Tetrahedralize' tetrahedralize1 = Tetrahedralize ( Input = manifoldCheck0vtu ) # create a new 'TTK ManifoldCheck' tTKManifoldCheck1 = TTKManifoldCheck ( Input = tetrahedralize1 ) # create a new 'Mask Points' maskPoints1 = MaskPoints ( Input = tTKManifoldCheck1 ) maskPoints1 . OnRatio = 1 maskPoints1 . MaximumNumberofPoints = 1000 maskPoints1 . GenerateVertices = 1 maskPoints1 . SingleVertexPerCell = 1 # create a new 'Threshold' # this extracts non-manifold vertices threshold1 = Threshold ( Input = maskPoints1 ) threshold1 . Scalars = [ 'POINTS' , 'VertexLinkComponentNumber' ] threshold1 . LowerThreshold = 2.0 threshold1 . UpperThreshold = 2.0 # save the output SaveData ( 'manifoldCheck0_check.vtu' , tTKManifoldCheck1 ) SaveData ( 'manifoldCheck0_non_manifold.vtu' , threshold1 ) Non-manifold Edges \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #!/usr/bin/env python from paraview.simple import * # create a new 'XML Unstructured Grid Reader' manifoldCheck1vtu = XMLUnstructuredGridReader ( FileName = [ 'manifoldCheck1.vtu' ]) # create a new 'Tetrahedralize' tetrahedralize2 = Tetrahedralize ( Input = manifoldCheck1vtu ) # create a new 'TTK ManifoldCheck' tTKManifoldCheck2 = TTKManifoldCheck ( Input = tetrahedralize2 ) # create a new 'Extract Edges' extractEdges2 = ExtractEdges ( Input = tTKManifoldCheck2 ) # create a new 'Threshold' # this extracts non-manifold edges threshold2 = Threshold ( Input = extractEdges2 ) threshold2 . Scalars = [ 'POINTS' , 'EdgeLinkComponentNumber' ] threshold2 . LowerThreshold = 2.0 threshold2 . UpperThreshold = 2.0 # save the output SaveData ( 'manifoldCheck1_check.vtu' , tTKManifoldCheck2 ) SaveData ( 'manifoldCheck1_non_manifold.vtu' , threshold2 ) Non-manifold Faces \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #!/usr/bin/env python from paraview.simple import * # create a new 'XML Unstructured Grid Reader' manifoldCheck2vtu = XMLUnstructuredGridReader ( FileName = [ 'manifoldCheck2.vtu' ]) # create a new 'Tetrahedralize' tetrahedralize3 = Tetrahedralize ( registrationName = 'Tetrahedralize3' , Input = manifoldCheck2vtu ) # create a new 'TTK ManifoldCheck' tTKManifoldCheck3 = TTKManifoldCheck ( registrationName = 'TTKManifoldCheck3' , Input = tetrahedralize3 ) # create a new 'Threshold' # this extracts tetrahedra that contain non-manifold faces threshold3 = Threshold ( registrationName = 'Threshold3' , Input = tTKManifoldCheck3 ) threshold3 . Scalars = [ 'CELLS' , 'TriangleLinkComponentNumber' ] threshold3 . LowerThreshold = 3.0 threshold3 . UpperThreshold = 3.0 # create a new 'Generate Ids' generateIds1 = GenerateIds ( registrationName = 'GenerateIds1' , Input = threshold3 ) generateIds1 . PointIdsArrayName = 'VertexIdentifiers' generateIds1 . CellIdsArrayName = 'CellIdentifiers' # create a new 'Threshold' # select two of the tetrahedra threshold4 = Threshold ( registrationName = 'Threshold4' , Input = generateIds1 ) threshold4 . Scalars = [ 'CELLS' , 'CellIdentifiers' ] threshold4 . UpperThreshold = 1.0 # create a new 'Extract Surface' extractSurface2 = ExtractSurface ( registrationName = 'ExtractSurface2' , Input = threshold4 ) # create a new 'Threshold' # this extracts non-manifold faces threshold5 = Threshold ( registrationName = 'Threshold5' , Input = extractSurface2 ) threshold5 . Scalars = [ 'POINTS' , 'TriangleLinkComponentNumber' ] threshold5 . LowerThreshold = 3.0 threshold5 . UpperThreshold = 3.0 # save the output SaveData ( 'manifoldCheck2_check.vtu' , tTKManifoldCheck3 ) SaveData ( 'manifoldCheck2_non_manifold.vtu' , threshold5 ) Inputs \u00b6 manifoldCheck0.vtu : example mesh with non-manifold vertices manifoldCheck1.vtu : example mesh with non-manifold edges manifoldCheck2.vtu : example mesh with non-manifold faces Outputs \u00b6 manifoldCheck0_check.vtu , manifoldCheck1_check.vtu , manifoldCheck2_check.vtu : tetrhedralized geometry with link numbers manifoldCheck0_non_manifold.vtu : non-manifold vertices in manifoldCheck0.vtu manifoldCheck1_non_manifold.vtu : non-manifold edges in manifoldCheck1.vtu manifoldCheck2_non_manifold.vtu : non-manifold faces in manifoldCheck2.vtu C++/Python API \u00b6 ManifoldCheck","title":"Manifold Check"},{"location":"manifoldCheck/#manifold-check","text":"","title":"Manifold Check"},{"location":"manifoldCheck/#pipeline-description","text":"This example loads three different hexahedral geometry files from disk. In a pre-processing, each geometry is tetrahedralized, which is used as input data. On each of the three geometries, ManifoldCheck is executed. This filters adds link numbers to vertices and cells, which can be used to detect and extract non-manifold vertices (left), edges (middle), and faces (right).","title":"Pipeline description"},{"location":"manifoldCheck/#paraview","text":"To reproduce the above screenshot, go to your ttk-data directory and enter the following command: $ paraview states/manifoldChecks.pvsm","title":"ParaView"},{"location":"manifoldCheck/#python-code","text":"","title":"Python code"},{"location":"manifoldCheck/#non-manifold-vertices","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/usr/bin/env python from paraview.simple import * # create a new 'XML Unstructured Grid Reader' manifoldCheck0vtu = XMLUnstructuredGridReader ( FileName = [ 'manifoldCheck0.vtu' ]) # create a new 'Tetrahedralize' tetrahedralize1 = Tetrahedralize ( Input = manifoldCheck0vtu ) # create a new 'TTK ManifoldCheck' tTKManifoldCheck1 = TTKManifoldCheck ( Input = tetrahedralize1 ) # create a new 'Mask Points' maskPoints1 = MaskPoints ( Input = tTKManifoldCheck1 ) maskPoints1 . OnRatio = 1 maskPoints1 . MaximumNumberofPoints = 1000 maskPoints1 . GenerateVertices = 1 maskPoints1 . SingleVertexPerCell = 1 # create a new 'Threshold' # this extracts non-manifold vertices threshold1 = Threshold ( Input = maskPoints1 ) threshold1 . Scalars = [ 'POINTS' , 'VertexLinkComponentNumber' ] threshold1 . LowerThreshold = 2.0 threshold1 . UpperThreshold = 2.0 # save the output SaveData ( 'manifoldCheck0_check.vtu' , tTKManifoldCheck1 ) SaveData ( 'manifoldCheck0_non_manifold.vtu' , threshold1 )","title":"Non-manifold Vertices"},{"location":"manifoldCheck/#non-manifold-edges","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #!/usr/bin/env python from paraview.simple import * # create a new 'XML Unstructured Grid Reader' manifoldCheck1vtu = XMLUnstructuredGridReader ( FileName = [ 'manifoldCheck1.vtu' ]) # create a new 'Tetrahedralize' tetrahedralize2 = Tetrahedralize ( Input = manifoldCheck1vtu ) # create a new 'TTK ManifoldCheck' tTKManifoldCheck2 = TTKManifoldCheck ( Input = tetrahedralize2 ) # create a new 'Extract Edges' extractEdges2 = ExtractEdges ( Input = tTKManifoldCheck2 ) # create a new 'Threshold' # this extracts non-manifold edges threshold2 = Threshold ( Input = extractEdges2 ) threshold2 . Scalars = [ 'POINTS' , 'EdgeLinkComponentNumber' ] threshold2 . LowerThreshold = 2.0 threshold2 . UpperThreshold = 2.0 # save the output SaveData ( 'manifoldCheck1_check.vtu' , tTKManifoldCheck2 ) SaveData ( 'manifoldCheck1_non_manifold.vtu' , threshold2 )","title":"Non-manifold Edges"},{"location":"manifoldCheck/#non-manifold-faces","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #!/usr/bin/env python from paraview.simple import * # create a new 'XML Unstructured Grid Reader' manifoldCheck2vtu = XMLUnstructuredGridReader ( FileName = [ 'manifoldCheck2.vtu' ]) # create a new 'Tetrahedralize' tetrahedralize3 = Tetrahedralize ( registrationName = 'Tetrahedralize3' , Input = manifoldCheck2vtu ) # create a new 'TTK ManifoldCheck' tTKManifoldCheck3 = TTKManifoldCheck ( registrationName = 'TTKManifoldCheck3' , Input = tetrahedralize3 ) # create a new 'Threshold' # this extracts tetrahedra that contain non-manifold faces threshold3 = Threshold ( registrationName = 'Threshold3' , Input = tTKManifoldCheck3 ) threshold3 . Scalars = [ 'CELLS' , 'TriangleLinkComponentNumber' ] threshold3 . LowerThreshold = 3.0 threshold3 . UpperThreshold = 3.0 # create a new 'Generate Ids' generateIds1 = GenerateIds ( registrationName = 'GenerateIds1' , Input = threshold3 ) generateIds1 . PointIdsArrayName = 'VertexIdentifiers' generateIds1 . CellIdsArrayName = 'CellIdentifiers' # create a new 'Threshold' # select two of the tetrahedra threshold4 = Threshold ( registrationName = 'Threshold4' , Input = generateIds1 ) threshold4 . Scalars = [ 'CELLS' , 'CellIdentifiers' ] threshold4 . UpperThreshold = 1.0 # create a new 'Extract Surface' extractSurface2 = ExtractSurface ( registrationName = 'ExtractSurface2' , Input = threshold4 ) # create a new 'Threshold' # this extracts non-manifold faces threshold5 = Threshold ( registrationName = 'Threshold5' , Input = extractSurface2 ) threshold5 . Scalars = [ 'POINTS' , 'TriangleLinkComponentNumber' ] threshold5 . LowerThreshold = 3.0 threshold5 . UpperThreshold = 3.0 # save the output SaveData ( 'manifoldCheck2_check.vtu' , tTKManifoldCheck3 ) SaveData ( 'manifoldCheck2_non_manifold.vtu' , threshold5 )","title":"Non-manifold Faces"},{"location":"manifoldCheck/#inputs","text":"manifoldCheck0.vtu : example mesh with non-manifold vertices manifoldCheck1.vtu : example mesh with non-manifold edges manifoldCheck2.vtu : example mesh with non-manifold faces","title":"Inputs"},{"location":"manifoldCheck/#outputs","text":"manifoldCheck0_check.vtu , manifoldCheck1_check.vtu , manifoldCheck2_check.vtu : tetrhedralized geometry with link numbers manifoldCheck0_non_manifold.vtu : non-manifold vertices in manifoldCheck0.vtu manifoldCheck1_non_manifold.vtu : non-manifold edges in manifoldCheck1.vtu manifoldCheck2_non_manifold.vtu : non-manifold faces in manifoldCheck2.vtu","title":"Outputs"},{"location":"manifoldCheck/#cpython-api","text":"ManifoldCheck","title":"C++/Python API"},{"location":"morseMolecule/","text":"Morse molecule example \u00b6 Pipeline description \u00b6 This example first loads a VTI file on the disk. The VTI file contains three scalar fields namely Rho , log(Rho) , and log(s) . We are interested in topological analysis of the log(Rho) scalar field which corresponds to the electron density distribution around a simple molecule. The MorseSmaleComplex is computed for this scalar field. The reason for computing Morse-Smale complex is that many chemically relevant concepts, for example, covalent bonds can be directly translated to topological structures computed using the Morse-Smale complex. The critical points of this scalar field also have chemical relevance. The maxima correspond to the atom locations and 2-saddles occur along chemical bonds. Then the critical points are then converted into spheres using IcospheresFromPoints . The maxima are selected and highlighted as bigger spheres. Then using appropriate filtering, the 1-separatrices corresponding to the covalent bonds are selected. The criteria used is to select the 1-sepatrices which have no critical points on the boundary and for which SeparatrixType = 2 , that is they connect a 2-saddle to a maximum. Also, GeometrySmoother is used to make the jagged lines generated by the Morse-Smale complex a little smoother. Then, another type of 1-separatrix is extracted which connects a 2-saddle on a covalent bond to its neighbouring 1-saddles on the boundary. Lastly, 2-separatrices incident on the covalent bonds (of SeparatrixType = 1 ) are extracted which correspond to separating walls between adjacent atoms. Another type ( SeparatrixType = 2 ) of separating wall is also extracted. ParaView \u00b6 To reproduce the above screenshot, go to your ttk-data directory and enter the following command: $ paraview states/morseMolecule.pvsm Python code \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 from paraview.simple import * # create a new 'XML Image Data Reader' builtInExamplevti = XMLImageDataReader ( FileName = [ 'BuiltInExample2.vti' ]) # create a new 'TTK MorseSmaleComplex' tTKMorseSmaleComplex1 = TTKMorseSmaleComplex ( Input = builtInExamplevti ) tTKMorseSmaleComplex1 . ScalarField = [ 'POINTS' , 'log(Rho)' ] tTKMorseSmaleComplex1 . Ascending2Separatrices = 1 tTKMorseSmaleComplex1 . Descending2Separatrices = 1 # Generate spheres for the critical points using 'TTK IcospheresFromPoints' tTKIcospheresFromPoints1 = TTKIcospheresFromPoints ( Input = tTKMorseSmaleComplex1 ) tTKIcospheresFromPoints1 . Radius = 1.5 # Generate bigger spheres for the critical points using 'TTK IcospheresFromPoints' tTKIcospheresFromPoints2 = TTKIcospheresFromPoints ( Input = tTKMorseSmaleComplex1 ) tTKIcospheresFromPoints2 . Radius = 3.0 # Then select critical points of CellDimension 3 using 'Threshold' to select maxima threshold3 = Threshold ( Input = tTKIcospheresFromPoints2 ) threshold3 . Scalars = [ 'POINTS' , 'CellDimension' ] threshold3 . ThresholdRange = [ 3.0 , 3.0 ] # create a new 'Threshold' threshold1 = Threshold ( Input = OutputPort ( tTKMorseSmaleComplex1 , 1 )) threshold1 . Scalars = [ 'CELLS' , 'NumberOfCriticalPointsOnBoundary' ] threshold1 . ThresholdRange = [ 0.0 , 0.0 ] # create a new 'Threshold' threshold2 = Threshold ( Input = threshold1 ) threshold2 . Scalars = [ 'CELLS' , 'SeparatrixType' ] threshold2 . ThresholdRange = [ 2.0 , 2.0 ] # create a new 'TTK GeometrySmoother' tTKGeometrySmoother1 = TTKGeometrySmoother ( Input = threshold2 ) tTKGeometrySmoother1 . IterationNumber = 50 # create a new 'Clean to Grid' cleantoGrid1 = CleantoGrid ( Input = tTKGeometrySmoother1 ) # create a new 'Extract Surface' extractSurface1 = ExtractSurface ( Input = cleantoGrid1 ) # create a new 'Tube' tube1 = Tube ( Input = extractSurface1 ) tube1 . Scalars = [ 'POINTS' , 'CellDimension' ] tube1 . Radius = 1.25 # create a new 'Threshold' threshold8 = Threshold ( Input = OutputPort ( tTKMorseSmaleComplex1 , 1 )) threshold8 . Scalars = [ 'CELLS' , 'SeparatrixType' ] threshold8 . ThresholdRange = [ 1.0 , 1.0 ] # create a new 'Threshold' threshold9 = Threshold ( Input = threshold8 ) threshold9 . Scalars = [ 'CELLS' , 'NumberOfCriticalPointsOnBoundary' ] threshold9 . ThresholdRange = [ 1.0 , 1.0 ] # create a new 'Threshold' threshold11 = Threshold ( Input = threshold9 ) threshold11 . Scalars = [ 'CELLS' , 'SeparatrixId' ] threshold11 . ThresholdRange = [ 75.0 , 76.0 ] # create a new 'Threshold' threshold10 = Threshold ( Input = threshold9 ) threshold10 . Scalars = [ 'CELLS' , 'SeparatrixId' ] threshold10 . ThresholdRange = [ 73.0 , 74.0 ] # create a new 'Append Datasets' appendDatasets1 = AppendDatasets ( Input = [ threshold10 , threshold11 ]) # create a new 'Clean to Grid' cleantoGrid4 = CleantoGrid ( Input = appendDatasets1 ) # create a new 'TTK GeometrySmoother' tTKGeometrySmoother4 = TTKGeometrySmoother ( Input = cleantoGrid4 ) tTKGeometrySmoother4 . IterationNumber = 10 # create a new 'Extract Surface' extractSurface3 = ExtractSurface ( Input = tTKGeometrySmoother4 ) # create a new 'Tube' tube2 = Tube ( Input = extractSurface3 ) tube2 . Scalars = [ 'POINTS' , 'CellDimension' ] tube2 . Radius = 0.75 # create a new 'Threshold' threshold4 = Threshold ( Input = OutputPort ( tTKMorseSmaleComplex1 , 2 )) threshold4 . Scalars = [ 'CELLS' , 'SeparatrixType' ] threshold4 . ThresholdRange = [ 1.0 , 1.0 ] # create a new 'Clean to Grid' cleantoGrid2 = CleantoGrid ( Input = threshold4 ) # create a new 'Tetrahedralize' tetrahedralize1 = Tetrahedralize ( Input = cleantoGrid2 ) # create a new 'Extract Surface' extractSurface2 = ExtractSurface ( Input = tetrahedralize1 ) # create a new 'TTK GeometrySmoother' tTKGeometrySmoother2 = TTKGeometrySmoother ( Input = extractSurface2 ) tTKGeometrySmoother2 . IterationNumber = 20 # select 2-separatrices using 'Threshold' threshold5 = Threshold ( Input = OutputPort ( tTKMorseSmaleComplex1 , 2 )) threshold5 . Scalars = [ 'CELLS' , 'SeparatrixType' ] threshold5 . ThresholdRange = [ 2.0 , 2.0 ] # create a new 'Threshold' threshold6 = Threshold ( Input = threshold5 ) threshold6 . Scalars = [ 'CELLS' , 'NumberOfCriticalPointsOnBoundary' ] threshold6 . ThresholdRange = [ 4.0 , 4.0 ] # select a particular 2-separatrix using 'Threshold' threshold7 = Threshold ( Input = threshold6 ) threshold7 . Scalars = [ 'CELLS' , 'SeparatrixId' ] threshold7 . ThresholdRange = [ 2.0 , 2.0 ] # create a new 'Clean to Grid' cleantoGrid3 = CleantoGrid ( Input = threshold7 ) # create a new 'Tetrahedralize' tetrahedralize2 = Tetrahedralize ( Input = cleantoGrid3 ) # create a new 'TTK GeometrySmoother' tTKGeometrySmoother3 = TTKGeometrySmoother ( Input = tetrahedralize2 ) tTKGeometrySmoother3 . IterationNumber = 20 # save the output SaveData ( 'CriticalPoints.vtp' , tTKIcospheresFromPoints1 ) SaveData ( 'Maxima.vtu' , threshold3 ) SaveData ( 'CovalentBonds.vtp' , tube1 ) SaveData ( 'Selected2saddle1saddleConnectors.vtp' , tube2 ) SaveData ( 'CovalentBondSeparatrixWalls.vtp' , tTKGeometrySmoother2 ) SaveData ( 'SelectedType2SeparatrixWall.vtu' , tTKGeometrySmoother3 ) Inputs \u00b6 BuiltInExample2.vti : 3D scalar field corresponding to electron density distribution around a simple molecule. Outputs \u00b6 CriticalPoints.vtp : All the output critical points in VTK file format (small spheres in the above screenshot). Maxima.vtu : The computed maxima which also correspond to atom locations in VTK file format (bigger green spheres). CovalentBonds.vtp : Selected 1-separatrices corresponding to the covalent bonds in the molecule (the thick white tubes) Selected2saddle1saddleConnectors.vtp : Geometry of selected separatrices connecting a 2-saddle on a covalent bond to its neighbouring 1-saddles (the dark grey tubes in the screenshot above). CovalentBondSeparatrixWalls.vtp : Surface corresponding to 2-separatrices (walls) incident on the covalent bonds (the translucent blue surfaces in the above screenshot) SelectedType2SeparatrixWall.vtu : Surface corresponding to another type of wall (the green surface). Note that you are free to change the VTK file extensions to that of any other supported file format (e.g. csv ) in the above python script. C++/Python API \u00b6 MorseSmaleComplex GeometrySmoother IcospheresFromPoints","title":"Morse molecule example"},{"location":"morseMolecule/#morse-molecule-example","text":"","title":"Morse molecule example"},{"location":"morseMolecule/#pipeline-description","text":"This example first loads a VTI file on the disk. The VTI file contains three scalar fields namely Rho , log(Rho) , and log(s) . We are interested in topological analysis of the log(Rho) scalar field which corresponds to the electron density distribution around a simple molecule. The MorseSmaleComplex is computed for this scalar field. The reason for computing Morse-Smale complex is that many chemically relevant concepts, for example, covalent bonds can be directly translated to topological structures computed using the Morse-Smale complex. The critical points of this scalar field also have chemical relevance. The maxima correspond to the atom locations and 2-saddles occur along chemical bonds. Then the critical points are then converted into spheres using IcospheresFromPoints . The maxima are selected and highlighted as bigger spheres. Then using appropriate filtering, the 1-separatrices corresponding to the covalent bonds are selected. The criteria used is to select the 1-sepatrices which have no critical points on the boundary and for which SeparatrixType = 2 , that is they connect a 2-saddle to a maximum. Also, GeometrySmoother is used to make the jagged lines generated by the Morse-Smale complex a little smoother. Then, another type of 1-separatrix is extracted which connects a 2-saddle on a covalent bond to its neighbouring 1-saddles on the boundary. Lastly, 2-separatrices incident on the covalent bonds (of SeparatrixType = 1 ) are extracted which correspond to separating walls between adjacent atoms. Another type ( SeparatrixType = 2 ) of separating wall is also extracted.","title":"Pipeline description"},{"location":"morseMolecule/#paraview","text":"To reproduce the above screenshot, go to your ttk-data directory and enter the following command: $ paraview states/morseMolecule.pvsm","title":"ParaView"},{"location":"morseMolecule/#python-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 from paraview.simple import * # create a new 'XML Image Data Reader' builtInExamplevti = XMLImageDataReader ( FileName = [ 'BuiltInExample2.vti' ]) # create a new 'TTK MorseSmaleComplex' tTKMorseSmaleComplex1 = TTKMorseSmaleComplex ( Input = builtInExamplevti ) tTKMorseSmaleComplex1 . ScalarField = [ 'POINTS' , 'log(Rho)' ] tTKMorseSmaleComplex1 . Ascending2Separatrices = 1 tTKMorseSmaleComplex1 . Descending2Separatrices = 1 # Generate spheres for the critical points using 'TTK IcospheresFromPoints' tTKIcospheresFromPoints1 = TTKIcospheresFromPoints ( Input = tTKMorseSmaleComplex1 ) tTKIcospheresFromPoints1 . Radius = 1.5 # Generate bigger spheres for the critical points using 'TTK IcospheresFromPoints' tTKIcospheresFromPoints2 = TTKIcospheresFromPoints ( Input = tTKMorseSmaleComplex1 ) tTKIcospheresFromPoints2 . Radius = 3.0 # Then select critical points of CellDimension 3 using 'Threshold' to select maxima threshold3 = Threshold ( Input = tTKIcospheresFromPoints2 ) threshold3 . Scalars = [ 'POINTS' , 'CellDimension' ] threshold3 . ThresholdRange = [ 3.0 , 3.0 ] # create a new 'Threshold' threshold1 = Threshold ( Input = OutputPort ( tTKMorseSmaleComplex1 , 1 )) threshold1 . Scalars = [ 'CELLS' , 'NumberOfCriticalPointsOnBoundary' ] threshold1 . ThresholdRange = [ 0.0 , 0.0 ] # create a new 'Threshold' threshold2 = Threshold ( Input = threshold1 ) threshold2 . Scalars = [ 'CELLS' , 'SeparatrixType' ] threshold2 . ThresholdRange = [ 2.0 , 2.0 ] # create a new 'TTK GeometrySmoother' tTKGeometrySmoother1 = TTKGeometrySmoother ( Input = threshold2 ) tTKGeometrySmoother1 . IterationNumber = 50 # create a new 'Clean to Grid' cleantoGrid1 = CleantoGrid ( Input = tTKGeometrySmoother1 ) # create a new 'Extract Surface' extractSurface1 = ExtractSurface ( Input = cleantoGrid1 ) # create a new 'Tube' tube1 = Tube ( Input = extractSurface1 ) tube1 . Scalars = [ 'POINTS' , 'CellDimension' ] tube1 . Radius = 1.25 # create a new 'Threshold' threshold8 = Threshold ( Input = OutputPort ( tTKMorseSmaleComplex1 , 1 )) threshold8 . Scalars = [ 'CELLS' , 'SeparatrixType' ] threshold8 . ThresholdRange = [ 1.0 , 1.0 ] # create a new 'Threshold' threshold9 = Threshold ( Input = threshold8 ) threshold9 . Scalars = [ 'CELLS' , 'NumberOfCriticalPointsOnBoundary' ] threshold9 . ThresholdRange = [ 1.0 , 1.0 ] # create a new 'Threshold' threshold11 = Threshold ( Input = threshold9 ) threshold11 . Scalars = [ 'CELLS' , 'SeparatrixId' ] threshold11 . ThresholdRange = [ 75.0 , 76.0 ] # create a new 'Threshold' threshold10 = Threshold ( Input = threshold9 ) threshold10 . Scalars = [ 'CELLS' , 'SeparatrixId' ] threshold10 . ThresholdRange = [ 73.0 , 74.0 ] # create a new 'Append Datasets' appendDatasets1 = AppendDatasets ( Input = [ threshold10 , threshold11 ]) # create a new 'Clean to Grid' cleantoGrid4 = CleantoGrid ( Input = appendDatasets1 ) # create a new 'TTK GeometrySmoother' tTKGeometrySmoother4 = TTKGeometrySmoother ( Input = cleantoGrid4 ) tTKGeometrySmoother4 . IterationNumber = 10 # create a new 'Extract Surface' extractSurface3 = ExtractSurface ( Input = tTKGeometrySmoother4 ) # create a new 'Tube' tube2 = Tube ( Input = extractSurface3 ) tube2 . Scalars = [ 'POINTS' , 'CellDimension' ] tube2 . Radius = 0.75 # create a new 'Threshold' threshold4 = Threshold ( Input = OutputPort ( tTKMorseSmaleComplex1 , 2 )) threshold4 . Scalars = [ 'CELLS' , 'SeparatrixType' ] threshold4 . ThresholdRange = [ 1.0 , 1.0 ] # create a new 'Clean to Grid' cleantoGrid2 = CleantoGrid ( Input = threshold4 ) # create a new 'Tetrahedralize' tetrahedralize1 = Tetrahedralize ( Input = cleantoGrid2 ) # create a new 'Extract Surface' extractSurface2 = ExtractSurface ( Input = tetrahedralize1 ) # create a new 'TTK GeometrySmoother' tTKGeometrySmoother2 = TTKGeometrySmoother ( Input = extractSurface2 ) tTKGeometrySmoother2 . IterationNumber = 20 # select 2-separatrices using 'Threshold' threshold5 = Threshold ( Input = OutputPort ( tTKMorseSmaleComplex1 , 2 )) threshold5 . Scalars = [ 'CELLS' , 'SeparatrixType' ] threshold5 . ThresholdRange = [ 2.0 , 2.0 ] # create a new 'Threshold' threshold6 = Threshold ( Input = threshold5 ) threshold6 . Scalars = [ 'CELLS' , 'NumberOfCriticalPointsOnBoundary' ] threshold6 . ThresholdRange = [ 4.0 , 4.0 ] # select a particular 2-separatrix using 'Threshold' threshold7 = Threshold ( Input = threshold6 ) threshold7 . Scalars = [ 'CELLS' , 'SeparatrixId' ] threshold7 . ThresholdRange = [ 2.0 , 2.0 ] # create a new 'Clean to Grid' cleantoGrid3 = CleantoGrid ( Input = threshold7 ) # create a new 'Tetrahedralize' tetrahedralize2 = Tetrahedralize ( Input = cleantoGrid3 ) # create a new 'TTK GeometrySmoother' tTKGeometrySmoother3 = TTKGeometrySmoother ( Input = tetrahedralize2 ) tTKGeometrySmoother3 . IterationNumber = 20 # save the output SaveData ( 'CriticalPoints.vtp' , tTKIcospheresFromPoints1 ) SaveData ( 'Maxima.vtu' , threshold3 ) SaveData ( 'CovalentBonds.vtp' , tube1 ) SaveData ( 'Selected2saddle1saddleConnectors.vtp' , tube2 ) SaveData ( 'CovalentBondSeparatrixWalls.vtp' , tTKGeometrySmoother2 ) SaveData ( 'SelectedType2SeparatrixWall.vtu' , tTKGeometrySmoother3 )","title":"Python code"},{"location":"morseMolecule/#inputs","text":"BuiltInExample2.vti : 3D scalar field corresponding to electron density distribution around a simple molecule.","title":"Inputs"},{"location":"morseMolecule/#outputs","text":"CriticalPoints.vtp : All the output critical points in VTK file format (small spheres in the above screenshot). Maxima.vtu : The computed maxima which also correspond to atom locations in VTK file format (bigger green spheres). CovalentBonds.vtp : Selected 1-separatrices corresponding to the covalent bonds in the molecule (the thick white tubes) Selected2saddle1saddleConnectors.vtp : Geometry of selected separatrices connecting a 2-saddle on a covalent bond to its neighbouring 1-saddles (the dark grey tubes in the screenshot above). CovalentBondSeparatrixWalls.vtp : Surface corresponding to 2-separatrices (walls) incident on the covalent bonds (the translucent blue surfaces in the above screenshot) SelectedType2SeparatrixWall.vtu : Surface corresponding to another type of wall (the green surface). Note that you are free to change the VTK file extensions to that of any other supported file format (e.g. csv ) in the above python script.","title":"Outputs"},{"location":"morseMolecule/#cpython-api","text":"MorseSmaleComplex GeometrySmoother IcospheresFromPoints","title":"C++/Python API"},{"location":"morsePersistence/","text":"Morse persistence example \u00b6 Pipeline description \u00b6 This example first loads a triangle mesh from disk. In a pre-processing, the mesh is smoothed and an elevation function is computed on top of it. The elevation function will be considered as the input scalar data in the remainder. Then, the PersistenceDiagram is computed and thresholds are applied base on persistence to maintain only the most persistent features. This results in a simplified persistence diagram (bottom right view in the above screenshot). The PersistenceCurve is also computed (top right view in the above screenshot). The simplified persistence diagram is then used as a constraint for the TopologicalSimplification of the input scalar data. This simplified data is then used as the input of the computation of ScalarFieldCriticalPoints (top left view, above screenshot) and the ContourTree (FTM) (bottom left view, above screenshot). ParaView \u00b6 To reproduce the above screenshot, go to your ttk-data directory and enter the following command: $ paraview states/dragon.pvsm Python code \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #!/usr/bin/env python from paraview.simple import * # create a new 'XML Unstructured Grid Reader' dragonvtu = XMLUnstructuredGridReader ( FileName = [ 'dragon.vtu' ]) # create a new 'TTK GeometrySmoother' tTKGeometrySmoother1 = TTKGeometrySmoother ( Input = dragonvtu ) # create a new 'Calculator' elevation = Calculator ( Input = tTKGeometrySmoother1 ) elevation . ResultArrayName = 'Elevation' elevation . Function = 'coordsY' # create a new 'TTK PersistenceCurve' tTKPersistenceCurve1 = TTKPersistenceCurve ( Input = elevation ) tTKPersistenceCurve1 . ScalarField = [ 'POINTS' , 'Elevation' ] # create a new 'TTK PersistenceDiagram' tTKPersistenceDiagram1 = TTKPersistenceDiagram ( Input = elevation ) tTKPersistenceDiagram1 . ScalarField = [ 'POINTS' , 'Elevation' ] # create a new 'Threshold' pairs = Threshold ( Input = tTKPersistenceDiagram1 ) pairs . Scalars = [ 'CELLS' , 'PairIdentifier' ] pairs . ThresholdRange = [ 0.0 , 1000.0 ] # create a new 'Threshold' persistenceThreshold = Threshold ( Input = pairs ) persistenceThreshold . Scalars = [ 'CELLS' , 'Persistence' ] persistenceThreshold . ThresholdRange = [ 5.0 , 1000.0 ] # create a new 'TTK TopologicalSimplification' tTKTopologicalSimplification1 = TTKTopologicalSimplification ( Domain = elevation , Constraints = persistenceThreshold ) tTKTopologicalSimplification1 . ScalarField = [ 'POINTS' , 'Elevation' ] # create a new 'TTK ScalarFieldCriticalPoints' tTKScalarFieldCriticalPoints1 = TTKScalarFieldCriticalPoints ( Input = tTKTopologicalSimplification1 ) tTKScalarFieldCriticalPoints1 . ScalarField = [ 'POINTS' , 'Elevation' ] # create a new 'TTK Merge and Contour Tree (FTM)' tTKContourTree1 = TTKMergeandContourTreeFTM ( Input = tTKTopologicalSimplification1 ) tTKContourTree1 . ScalarField = [ 'POINTS' , 'Elevation' ] tTKContourTree1 . ArcSampling = 30 # create a new 'TTK GeometrySmoother' tTKGeometrySmoother2 = TTKGeometrySmoother ( Input = OutputPort ( tTKContourTree1 , 1 )) tTKGeometrySmoother2 . IterationNumber = 40 # create a new 'Extract Surface' extractSurface4 = ExtractSurface ( Input = tTKGeometrySmoother2 ) # create a new 'Tube' tube4 = Tube ( Input = extractSurface4 ) tube4 . NumberofSides = 12 tube4 . Radius = 0.75 # create a new 'TTK IcospheresFromPoints' tTKIcospheresFromPoints4 = TTKIcospheresFromPoints ( Input = tTKContourTree1 ) tTKIcospheresFromPoints4 . Radius = 2.0 # save the output SaveData ( 'PersistenceDiagram.vtu' , tTKPersistenceDiagram1 ) SaveData ( 'PersistenceCurve.csv' , OutputPort ( tTKPersistenceCurve1 , 3 )) SaveData ( 'CriticalPoints.vtp' , tTKScalarFieldCriticalPoints1 ) SaveData ( 'ContourTreeNodes.vtp' , tTKIcospheresFromPoints4 ) SaveData ( 'ContourTreeArcs.vtp' , tube4 ) Inputs \u00b6 dragon.vtu : a two-dimensional triangulation. Outputs \u00b6 PersistenceDiagram.vtu : the output persistence diagram in VTK file format (bottom right view, above screenshot). You are free to change the vtu file extension to that of any other supported file format (e.g. csv ) in the above python script. PersistenceCurve.csv : the output persistence curve. CriticalPoints.vtp : the output critical points in VTK file format (bottom right view, above screenshot). You are free to change the vtp file extension to that of any other supported file format (e.g. csv ) in the above python script. ContourTreeNode.vtp : spheres, representing the nodes of the output contour tree in VTK file format (bottom right view, above screenshot). You are free to change the vtp file extension to that of any other supported file format (e.g. csv ) in the above python script. ContourTreeArcs.vtp : cylinders, representing the arcs of the output contour tree in VTK file format (bottom right view, above screenshot). You are free to change the vtp file extension to that of any other supported file format (e.g. csv ) in the above python script. C++/Python API \u00b6 ContourTree (FTM) GeometrySmoother IcospheresFromPoints PersistenceCurve PersistenceDiagram ScalarFieldCriticalPoints TopologicalSimplification","title":"Morse persistence example"},{"location":"morsePersistence/#morse-persistence-example","text":"","title":"Morse persistence example"},{"location":"morsePersistence/#pipeline-description","text":"This example first loads a triangle mesh from disk. In a pre-processing, the mesh is smoothed and an elevation function is computed on top of it. The elevation function will be considered as the input scalar data in the remainder. Then, the PersistenceDiagram is computed and thresholds are applied base on persistence to maintain only the most persistent features. This results in a simplified persistence diagram (bottom right view in the above screenshot). The PersistenceCurve is also computed (top right view in the above screenshot). The simplified persistence diagram is then used as a constraint for the TopologicalSimplification of the input scalar data. This simplified data is then used as the input of the computation of ScalarFieldCriticalPoints (top left view, above screenshot) and the ContourTree (FTM) (bottom left view, above screenshot).","title":"Pipeline description"},{"location":"morsePersistence/#paraview","text":"To reproduce the above screenshot, go to your ttk-data directory and enter the following command: $ paraview states/dragon.pvsm","title":"ParaView"},{"location":"morsePersistence/#python-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #!/usr/bin/env python from paraview.simple import * # create a new 'XML Unstructured Grid Reader' dragonvtu = XMLUnstructuredGridReader ( FileName = [ 'dragon.vtu' ]) # create a new 'TTK GeometrySmoother' tTKGeometrySmoother1 = TTKGeometrySmoother ( Input = dragonvtu ) # create a new 'Calculator' elevation = Calculator ( Input = tTKGeometrySmoother1 ) elevation . ResultArrayName = 'Elevation' elevation . Function = 'coordsY' # create a new 'TTK PersistenceCurve' tTKPersistenceCurve1 = TTKPersistenceCurve ( Input = elevation ) tTKPersistenceCurve1 . ScalarField = [ 'POINTS' , 'Elevation' ] # create a new 'TTK PersistenceDiagram' tTKPersistenceDiagram1 = TTKPersistenceDiagram ( Input = elevation ) tTKPersistenceDiagram1 . ScalarField = [ 'POINTS' , 'Elevation' ] # create a new 'Threshold' pairs = Threshold ( Input = tTKPersistenceDiagram1 ) pairs . Scalars = [ 'CELLS' , 'PairIdentifier' ] pairs . ThresholdRange = [ 0.0 , 1000.0 ] # create a new 'Threshold' persistenceThreshold = Threshold ( Input = pairs ) persistenceThreshold . Scalars = [ 'CELLS' , 'Persistence' ] persistenceThreshold . ThresholdRange = [ 5.0 , 1000.0 ] # create a new 'TTK TopologicalSimplification' tTKTopologicalSimplification1 = TTKTopologicalSimplification ( Domain = elevation , Constraints = persistenceThreshold ) tTKTopologicalSimplification1 . ScalarField = [ 'POINTS' , 'Elevation' ] # create a new 'TTK ScalarFieldCriticalPoints' tTKScalarFieldCriticalPoints1 = TTKScalarFieldCriticalPoints ( Input = tTKTopologicalSimplification1 ) tTKScalarFieldCriticalPoints1 . ScalarField = [ 'POINTS' , 'Elevation' ] # create a new 'TTK Merge and Contour Tree (FTM)' tTKContourTree1 = TTKMergeandContourTreeFTM ( Input = tTKTopologicalSimplification1 ) tTKContourTree1 . ScalarField = [ 'POINTS' , 'Elevation' ] tTKContourTree1 . ArcSampling = 30 # create a new 'TTK GeometrySmoother' tTKGeometrySmoother2 = TTKGeometrySmoother ( Input = OutputPort ( tTKContourTree1 , 1 )) tTKGeometrySmoother2 . IterationNumber = 40 # create a new 'Extract Surface' extractSurface4 = ExtractSurface ( Input = tTKGeometrySmoother2 ) # create a new 'Tube' tube4 = Tube ( Input = extractSurface4 ) tube4 . NumberofSides = 12 tube4 . Radius = 0.75 # create a new 'TTK IcospheresFromPoints' tTKIcospheresFromPoints4 = TTKIcospheresFromPoints ( Input = tTKContourTree1 ) tTKIcospheresFromPoints4 . Radius = 2.0 # save the output SaveData ( 'PersistenceDiagram.vtu' , tTKPersistenceDiagram1 ) SaveData ( 'PersistenceCurve.csv' , OutputPort ( tTKPersistenceCurve1 , 3 )) SaveData ( 'CriticalPoints.vtp' , tTKScalarFieldCriticalPoints1 ) SaveData ( 'ContourTreeNodes.vtp' , tTKIcospheresFromPoints4 ) SaveData ( 'ContourTreeArcs.vtp' , tube4 )","title":"Python code"},{"location":"morsePersistence/#inputs","text":"dragon.vtu : a two-dimensional triangulation.","title":"Inputs"},{"location":"morsePersistence/#outputs","text":"PersistenceDiagram.vtu : the output persistence diagram in VTK file format (bottom right view, above screenshot). You are free to change the vtu file extension to that of any other supported file format (e.g. csv ) in the above python script. PersistenceCurve.csv : the output persistence curve. CriticalPoints.vtp : the output critical points in VTK file format (bottom right view, above screenshot). You are free to change the vtp file extension to that of any other supported file format (e.g. csv ) in the above python script. ContourTreeNode.vtp : spheres, representing the nodes of the output contour tree in VTK file format (bottom right view, above screenshot). You are free to change the vtp file extension to that of any other supported file format (e.g. csv ) in the above python script. ContourTreeArcs.vtp : cylinders, representing the arcs of the output contour tree in VTK file format (bottom right view, above screenshot). You are free to change the vtp file extension to that of any other supported file format (e.g. csv ) in the above python script.","title":"Outputs"},{"location":"morsePersistence/#cpython-api","text":"ContourTree (FTM) GeometrySmoother IcospheresFromPoints PersistenceCurve PersistenceDiagram ScalarFieldCriticalPoints TopologicalSimplification","title":"C++/Python API"}]}