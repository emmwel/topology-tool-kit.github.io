{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to TTK Examples \u00b6 This website hosts a list of data analysis pipelines exemplifying TTK's usage with ParaView and its Python API pvpython . The website is targeting novice users would are not power users of ParaView , and who would like to get started with topological data analysis with TTK in Python. Each example includes a screenshot (or a tutorial video), the command to execute to reproduce the example with ParaView as well as the corresponding Python code to process the input data, and store the output of the analysis pipeline to disk. This documentation assumes a default TTK installation, with the pvpython API support enabled. List of available examples \u00b6 Scalar data \u00b6 dragon Bivariate scalar data \u00b6 Uncertain scalar data \u00b6 Time-varying scalar data \u00b6 Ensemble scalar data \u00b6 High-dimensional / point cloud data \u00b6 Cinema features \u00b6 Misc features \u00b6","title":"Welcome to TTK Examples"},{"location":"#welcome-to-ttk-examples","text":"This website hosts a list of data analysis pipelines exemplifying TTK's usage with ParaView and its Python API pvpython . The website is targeting novice users would are not power users of ParaView , and who would like to get started with topological data analysis with TTK in Python. Each example includes a screenshot (or a tutorial video), the command to execute to reproduce the example with ParaView as well as the corresponding Python code to process the input data, and store the output of the analysis pipeline to disk. This documentation assumes a default TTK installation, with the pvpython API support enabled.","title":"Welcome to TTK Examples"},{"location":"#list-of-available-examples","text":"","title":"List of available examples"},{"location":"#scalar-data","text":"dragon","title":"Scalar data"},{"location":"#bivariate-scalar-data","text":"","title":"Bivariate scalar data"},{"location":"#uncertain-scalar-data","text":"","title":"Uncertain scalar data"},{"location":"#time-varying-scalar-data","text":"","title":"Time-varying scalar data"},{"location":"#ensemble-scalar-data","text":"","title":"Ensemble scalar data"},{"location":"#high-dimensional-point-cloud-data","text":"","title":"High-dimensional / point cloud data"},{"location":"#cinema-features","text":"","title":"Cinema features"},{"location":"#misc-features","text":"","title":"Misc features"},{"location":"dragon/","text":"Dragon example \u00b6 Pipeline description \u00b6 This example first loads a triangle mesh from disk. In a pre-processing, the mesh is smoothed and an elevation function is computed on top of it. The elevation function will be considered as the input scalar data in the remainder Then, the PersistenceDiagram is computed and thresholds are applied base on persistence to maintain only the most persistent features. This results in a simplified persistence diagram (bottom right view in the above screenshot). The PersistenceCurve is also computed (top right view in the above screenshot). The simplified persistence diagram is then used as a constraint for the TopologicalSimplification of the input scalar data. This simplified data is then used as the input of the computation of ScalarFieldCriticalPoints (top left view, above screenshot) and the ContourTree (FTM) (bottom left view, above screenshot). Python code \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 #!/usr/bin/env python from paraview.simple import * # create a new 'XML Unstructured Grid Reader' dragonvtu = XMLUnstructuredGridReader ( registrationName = 'dragon.vtu' , FileName = [ 'dragon.vtu' ]) # create a new 'TTK GeometrySmoother' tTKGeometrySmoother1 = TTKGeometrySmoother ( registrationName = 'TTKGeometrySmoother1' , Input = dragonvtu ) tTKGeometrySmoother1 . InputMaskField = [ None , '' ] # create a new 'Calculator' elevation = Calculator ( registrationName = 'Elevation' , Input = tTKGeometrySmoother1 ) elevation . ResultArrayName = 'Elevation' elevation . Function = 'coordsY' # create a new 'TTK PersistenceCurve' tTKPersistenceCurve1 = TTKPersistenceCurve ( registrationName = 'TTKPersistenceCurve1' , Input = elevation ) tTKPersistenceCurve1 . ScalarField = [ 'POINTS' , 'Elevation' ] tTKPersistenceCurve1 . InputOffsetField = [ 'POINTS' , '' ] # create a new 'TTK PersistenceDiagram' tTKPersistenceDiagram1 = TTKPersistenceDiagram ( registrationName = 'TTKPersistenceDiagram1' , Input = elevation ) tTKPersistenceDiagram1 . ScalarField = [ 'POINTS' , 'Elevation' ] tTKPersistenceDiagram1 . InputOffsetField = [ None , '' ] # create a new 'Threshold' diagonal = Threshold ( registrationName = 'Diagonal' , Input = tTKPersistenceDiagram1 ) diagonal . Scalars = [ 'CELLS' , 'PairIdentifier' ] diagonal . ThresholdRange = [ - 1.0 , - 0.1 ] # create a new 'Extract Surface' extractSurface1 = ExtractSurface ( registrationName = 'ExtractSurface1' , Input = diagonal ) # create a new 'Tube' tube1 = Tube ( registrationName = 'Tube1' , Input = extractSurface1 ) tube1 . Scalars = [ 'POINTS' , 'CriticalType' ] tube1 . Vectors = [ None , '' ] # create a new 'Threshold' pairs = Threshold ( registrationName = 'Pairs' , Input = tTKPersistenceDiagram1 ) pairs . Scalars = [ 'CELLS' , 'PairIdentifier' ] pairs . ThresholdRange = [ 0.0 , 1000.0 ] # create a new 'Threshold' persistenceThreshold = Threshold ( registrationName = 'PersistenceThreshold' , Input = pairs ) persistenceThreshold . Scalars = [ 'CELLS' , 'Persistence' ] persistenceThreshold . ThresholdRange = [ 5.0 , 1000.0 ] # create a new 'TTK TopologicalSimplification' tTKTopologicalSimplification1 = TTKTopologicalSimplification ( registrationName = 'TTKTopologicalSimplification1' , Domain = elevation , Constraints = persistenceThreshold ) tTKTopologicalSimplification1 . ScalarField = [ 'POINTS' , 'Elevation' ] tTKTopologicalSimplification1 . InputOffsetField = [ None , '' ] tTKTopologicalSimplification1 . VertexIdentifierField = [ None , '' ] # create a new 'TTK ScalarFieldCriticalPoints' tTKScalarFieldCriticalPoints1 = TTKScalarFieldCriticalPoints ( registrationName = 'TTKScalarFieldCriticalPoints1' , Input = tTKTopologicalSimplification1 ) tTKScalarFieldCriticalPoints1 . ScalarField = [ 'POINTS' , 'Elevation' ] tTKScalarFieldCriticalPoints1 . InputOffsetField = [ 'POINTS' , 'OutputOffsetScalarField' ] tTKScalarFieldCriticalPoints1 . Withvertexidentifiers = 0 tTKScalarFieldCriticalPoints1 . Withvertexscalars = 0 # create a new 'TTK IcospheresFromPoints' tTKIcospheresFromPoints2 = TTKIcospheresFromPoints ( registrationName = 'TTKIcospheresFromPoints2' , Input = tTKScalarFieldCriticalPoints1 ) tTKIcospheresFromPoints2 . Radius = 1.5 # create a new 'Clean to Grid' cleantoGrid1 = CleantoGrid ( registrationName = 'CleantoGrid1' , Input = tTKTopologicalSimplification1 ) # create a new 'Extract Surface' extractSurface3 = ExtractSurface ( registrationName = 'ExtractSurface3' , Input = cleantoGrid1 ) # create a new 'Generate Surface Normals' generateSurfaceNormals1 = GenerateSurfaceNormals ( registrationName = 'GenerateSurfaceNormals1' , Input = extractSurface3 ) # create a new 'TTK Merge and Contour Tree (FTM)' tTKContourTree1 = TTKMergeandContourTreeFTM ( registrationName = 'TTKContourTree1' , Input = tTKTopologicalSimplification1 ) tTKContourTree1 . ScalarField = [ 'POINTS' , 'Elevation' ] tTKContourTree1 . InputOffsetField = [ 'POINTS' , 'OutputOffsetScalarField' ] tTKContourTree1 . ArcSampling = 30 # create a new 'Extract Surface' extractSurface2 = ExtractSurface ( registrationName = 'ExtractSurface2' , Input = persistenceThreshold ) # create a new 'Tube' tube2 = Tube ( registrationName = 'Tube2' , Input = extractSurface2 ) tube2 . Scalars = [ 'POINTS' , 'CriticalType' ] tube2 . Vectors = [ None , '' ] tube2 . Radius = 0.893286056518555 # create a new 'TTK IcospheresFromPoints' tTKIcospheresFromPoints1 = TTKIcospheresFromPoints ( registrationName = 'TTKIcospheresFromPoints1' , Input = persistenceThreshold ) tTKIcospheresFromPoints1 . Radius = 1.5 # find source tTKContourTree1_1 = FindSource ( 'TTKContourTree1' ) # create a new 'TTK GeometrySmoother' tTKGeometrySmoother2 = TTKGeometrySmoother ( registrationName = 'TTKGeometrySmoother2' , Input = OutputPort ( tTKContourTree1_1 , 1 )) tTKGeometrySmoother2 . IterationNumber = 40 tTKGeometrySmoother2 . InputMaskField = [ None , '' ] # create a new 'Extract Surface' extractSurface4 = ExtractSurface ( registrationName = 'ExtractSurface4' , Input = tTKGeometrySmoother2 ) # create a new 'Tube' tube4 = Tube ( registrationName = 'Tube4' , Input = extractSurface4 ) tube4 . Scalars = [ 'POINTS' , 'RegularMask' ] tube4 . Vectors = [ None , '' ] tube4 . NumberofSides = 12 tube4 . Radius = 0.75 # create a new 'TTK IcospheresFromPoints' tTKIcospheresFromPoints4 = TTKIcospheresFromPoints ( registrationName = 'TTKIcospheresFromPoints4' , Input = tTKContourTree1 ) tTKIcospheresFromPoints4 . Radius = 2.0 # save the output SaveData ( 'PersistenceDiagram.vtu' , tTKPersistenceDiagram1 ) SaveData ( 'PersistenceCurve.csv' , OutputPort ( tTKPersistenceCurve1 , 3 )) SaveData ( 'CriticalPoints.vtp' , tTKScalarFieldCriticalPoints1 ) SaveData ( 'ContourTreeNodes.vtp' , tTKIcospheresFromPoints4 ) SaveData ( 'ContourTreeArcs.vtp' , tube4 ) Inputs \u00b6 dragon.vtu : a two-dimensional triangulation. Outputs \u00b6 PersistenceDiagram.vtu : the output persistence diagram in VTK file format (bottom right view, above screenshot). You are free to change the vtu file extension to that of any other supported file format (e.g. csv ) in the above python script. PersistenceCurve.csv : the output persistence curve. CriticalPoints.vtp : the output critical points in VTK file format (bottom right view, above screenshot). You are free to change the vtp file extension to that of any other supported file format (e.g. csv ) in the above python script. ContourTreeNode.vtp : spheres, representing the nodes of the output contour tree in VTK file format (bottom right view, above screenshot). You are free to change the vtp file extension to that of any other supported file format (e.g. csv ) in the above python script. ContourTreeArcs.vtp : cylinders, representing the arcs of the output contour tree in VTK file format (bottom right view, above screenshot). You are free to change the vtp file extension to that of any other supported file format (e.g. csv ) in the above python script. C++/Python API \u00b6 ContourTree (FTM) GeometrySmoother IcospheresFromPoints PersistenceCurve PersistenceDiagram ScalarFieldCriticalPoints TopologicalSimplification","title":"Dragon example"},{"location":"dragon/#dragon-example","text":"","title":"Dragon example"},{"location":"dragon/#pipeline-description","text":"This example first loads a triangle mesh from disk. In a pre-processing, the mesh is smoothed and an elevation function is computed on top of it. The elevation function will be considered as the input scalar data in the remainder Then, the PersistenceDiagram is computed and thresholds are applied base on persistence to maintain only the most persistent features. This results in a simplified persistence diagram (bottom right view in the above screenshot). The PersistenceCurve is also computed (top right view in the above screenshot). The simplified persistence diagram is then used as a constraint for the TopologicalSimplification of the input scalar data. This simplified data is then used as the input of the computation of ScalarFieldCriticalPoints (top left view, above screenshot) and the ContourTree (FTM) (bottom left view, above screenshot).","title":"Pipeline description"},{"location":"dragon/#python-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 #!/usr/bin/env python from paraview.simple import * # create a new 'XML Unstructured Grid Reader' dragonvtu = XMLUnstructuredGridReader ( registrationName = 'dragon.vtu' , FileName = [ 'dragon.vtu' ]) # create a new 'TTK GeometrySmoother' tTKGeometrySmoother1 = TTKGeometrySmoother ( registrationName = 'TTKGeometrySmoother1' , Input = dragonvtu ) tTKGeometrySmoother1 . InputMaskField = [ None , '' ] # create a new 'Calculator' elevation = Calculator ( registrationName = 'Elevation' , Input = tTKGeometrySmoother1 ) elevation . ResultArrayName = 'Elevation' elevation . Function = 'coordsY' # create a new 'TTK PersistenceCurve' tTKPersistenceCurve1 = TTKPersistenceCurve ( registrationName = 'TTKPersistenceCurve1' , Input = elevation ) tTKPersistenceCurve1 . ScalarField = [ 'POINTS' , 'Elevation' ] tTKPersistenceCurve1 . InputOffsetField = [ 'POINTS' , '' ] # create a new 'TTK PersistenceDiagram' tTKPersistenceDiagram1 = TTKPersistenceDiagram ( registrationName = 'TTKPersistenceDiagram1' , Input = elevation ) tTKPersistenceDiagram1 . ScalarField = [ 'POINTS' , 'Elevation' ] tTKPersistenceDiagram1 . InputOffsetField = [ None , '' ] # create a new 'Threshold' diagonal = Threshold ( registrationName = 'Diagonal' , Input = tTKPersistenceDiagram1 ) diagonal . Scalars = [ 'CELLS' , 'PairIdentifier' ] diagonal . ThresholdRange = [ - 1.0 , - 0.1 ] # create a new 'Extract Surface' extractSurface1 = ExtractSurface ( registrationName = 'ExtractSurface1' , Input = diagonal ) # create a new 'Tube' tube1 = Tube ( registrationName = 'Tube1' , Input = extractSurface1 ) tube1 . Scalars = [ 'POINTS' , 'CriticalType' ] tube1 . Vectors = [ None , '' ] # create a new 'Threshold' pairs = Threshold ( registrationName = 'Pairs' , Input = tTKPersistenceDiagram1 ) pairs . Scalars = [ 'CELLS' , 'PairIdentifier' ] pairs . ThresholdRange = [ 0.0 , 1000.0 ] # create a new 'Threshold' persistenceThreshold = Threshold ( registrationName = 'PersistenceThreshold' , Input = pairs ) persistenceThreshold . Scalars = [ 'CELLS' , 'Persistence' ] persistenceThreshold . ThresholdRange = [ 5.0 , 1000.0 ] # create a new 'TTK TopologicalSimplification' tTKTopologicalSimplification1 = TTKTopologicalSimplification ( registrationName = 'TTKTopologicalSimplification1' , Domain = elevation , Constraints = persistenceThreshold ) tTKTopologicalSimplification1 . ScalarField = [ 'POINTS' , 'Elevation' ] tTKTopologicalSimplification1 . InputOffsetField = [ None , '' ] tTKTopologicalSimplification1 . VertexIdentifierField = [ None , '' ] # create a new 'TTK ScalarFieldCriticalPoints' tTKScalarFieldCriticalPoints1 = TTKScalarFieldCriticalPoints ( registrationName = 'TTKScalarFieldCriticalPoints1' , Input = tTKTopologicalSimplification1 ) tTKScalarFieldCriticalPoints1 . ScalarField = [ 'POINTS' , 'Elevation' ] tTKScalarFieldCriticalPoints1 . InputOffsetField = [ 'POINTS' , 'OutputOffsetScalarField' ] tTKScalarFieldCriticalPoints1 . Withvertexidentifiers = 0 tTKScalarFieldCriticalPoints1 . Withvertexscalars = 0 # create a new 'TTK IcospheresFromPoints' tTKIcospheresFromPoints2 = TTKIcospheresFromPoints ( registrationName = 'TTKIcospheresFromPoints2' , Input = tTKScalarFieldCriticalPoints1 ) tTKIcospheresFromPoints2 . Radius = 1.5 # create a new 'Clean to Grid' cleantoGrid1 = CleantoGrid ( registrationName = 'CleantoGrid1' , Input = tTKTopologicalSimplification1 ) # create a new 'Extract Surface' extractSurface3 = ExtractSurface ( registrationName = 'ExtractSurface3' , Input = cleantoGrid1 ) # create a new 'Generate Surface Normals' generateSurfaceNormals1 = GenerateSurfaceNormals ( registrationName = 'GenerateSurfaceNormals1' , Input = extractSurface3 ) # create a new 'TTK Merge and Contour Tree (FTM)' tTKContourTree1 = TTKMergeandContourTreeFTM ( registrationName = 'TTKContourTree1' , Input = tTKTopologicalSimplification1 ) tTKContourTree1 . ScalarField = [ 'POINTS' , 'Elevation' ] tTKContourTree1 . InputOffsetField = [ 'POINTS' , 'OutputOffsetScalarField' ] tTKContourTree1 . ArcSampling = 30 # create a new 'Extract Surface' extractSurface2 = ExtractSurface ( registrationName = 'ExtractSurface2' , Input = persistenceThreshold ) # create a new 'Tube' tube2 = Tube ( registrationName = 'Tube2' , Input = extractSurface2 ) tube2 . Scalars = [ 'POINTS' , 'CriticalType' ] tube2 . Vectors = [ None , '' ] tube2 . Radius = 0.893286056518555 # create a new 'TTK IcospheresFromPoints' tTKIcospheresFromPoints1 = TTKIcospheresFromPoints ( registrationName = 'TTKIcospheresFromPoints1' , Input = persistenceThreshold ) tTKIcospheresFromPoints1 . Radius = 1.5 # find source tTKContourTree1_1 = FindSource ( 'TTKContourTree1' ) # create a new 'TTK GeometrySmoother' tTKGeometrySmoother2 = TTKGeometrySmoother ( registrationName = 'TTKGeometrySmoother2' , Input = OutputPort ( tTKContourTree1_1 , 1 )) tTKGeometrySmoother2 . IterationNumber = 40 tTKGeometrySmoother2 . InputMaskField = [ None , '' ] # create a new 'Extract Surface' extractSurface4 = ExtractSurface ( registrationName = 'ExtractSurface4' , Input = tTKGeometrySmoother2 ) # create a new 'Tube' tube4 = Tube ( registrationName = 'Tube4' , Input = extractSurface4 ) tube4 . Scalars = [ 'POINTS' , 'RegularMask' ] tube4 . Vectors = [ None , '' ] tube4 . NumberofSides = 12 tube4 . Radius = 0.75 # create a new 'TTK IcospheresFromPoints' tTKIcospheresFromPoints4 = TTKIcospheresFromPoints ( registrationName = 'TTKIcospheresFromPoints4' , Input = tTKContourTree1 ) tTKIcospheresFromPoints4 . Radius = 2.0 # save the output SaveData ( 'PersistenceDiagram.vtu' , tTKPersistenceDiagram1 ) SaveData ( 'PersistenceCurve.csv' , OutputPort ( tTKPersistenceCurve1 , 3 )) SaveData ( 'CriticalPoints.vtp' , tTKScalarFieldCriticalPoints1 ) SaveData ( 'ContourTreeNodes.vtp' , tTKIcospheresFromPoints4 ) SaveData ( 'ContourTreeArcs.vtp' , tube4 )","title":"Python code"},{"location":"dragon/#inputs","text":"dragon.vtu : a two-dimensional triangulation.","title":"Inputs"},{"location":"dragon/#outputs","text":"PersistenceDiagram.vtu : the output persistence diagram in VTK file format (bottom right view, above screenshot). You are free to change the vtu file extension to that of any other supported file format (e.g. csv ) in the above python script. PersistenceCurve.csv : the output persistence curve. CriticalPoints.vtp : the output critical points in VTK file format (bottom right view, above screenshot). You are free to change the vtp file extension to that of any other supported file format (e.g. csv ) in the above python script. ContourTreeNode.vtp : spheres, representing the nodes of the output contour tree in VTK file format (bottom right view, above screenshot). You are free to change the vtp file extension to that of any other supported file format (e.g. csv ) in the above python script. ContourTreeArcs.vtp : cylinders, representing the arcs of the output contour tree in VTK file format (bottom right view, above screenshot). You are free to change the vtp file extension to that of any other supported file format (e.g. csv ) in the above python script.","title":"Outputs"},{"location":"dragon/#cpython-api","text":"ContourTree (FTM) GeometrySmoother IcospheresFromPoints PersistenceCurve PersistenceDiagram ScalarFieldCriticalPoints TopologicalSimplification","title":"C++/Python API"}]}